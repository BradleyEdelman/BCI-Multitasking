function [estimatedPhase, phaseLockFrequency, inputEnvelope] = c_estimatePhase(varargin)

if nargin==0, test_c_estimatePhase(); return; end;

p = inputParser();
p.addRequired('inputData',@isnumeric);
p.addRequired('Fs',@isscalar);
p.addParameter('inputTime',[],@isnumeric); % times for which we have data
p.addParameter('outputTime',[],@isnumeric); % times at which to estimate phase
p.addParameter('doPrefilter','auto',@islogical);
p.addParameter('filterNumeratorCoefficients',[],@isnumeric); % if empty, will be autogenerated with ~40 Hz low-pass filter
p.addParameter('doPlot',false,@islogical); % mainly for debugging
p.addParameter('method','morlet-symmetric',@ischar); % method for phase estimation
p.addParameter('preHilbertWindowFn',[],@(x) isa(x,'function_handle'));
p.addParameter('extrapolationMethod','extrapolatedWeightedSmoothingSpline',@ischar);
p.addParameter('doPreFilterExtrapolation',true,@islogical);
p.addParameter('doPreEstimationExtrapolation',true,@islogical); %TODO: change back to true
p.addParameter('doWeightExtrapolationByTime',true,@islogical);
p.addParameter('estimationPeriodDelay',1,@isscalar); % predict phase at time (t) using phase at time (t-T*estimationPeriodDelay)
p.addParameter('polynomialFitOrder',1,@isscalar);
p.addParameter('hilbertPercentToExclude',10,@isscalar); % percent of data to exclude at beginning and end (in total) of time course, to minimize boundary artifacts
p.addParameter('morlet_Fc',[],@isscalar);
p.addParameter('morlet_fractionOfWaveletToExclude',1,@isscalar); % data to exclude at beginning and end, as a fraction of the convolved wavelet length
p.addParameter('morlet_numCycles',6,@iscalar);
p.addParameter('morlet_bandwidthN',4,@isscalar);
p.parse(varargin{:});

sig = p.Results.inputData;
origSig = sig;
t = p.Results.inputTime;
Fs = p.Results.Fs;
doPlot = p.Results.doPlot;

if isempty(t)
	t = (0:length(sig)-1)/Fs;
else
	assert(length(t)==length(sig));
end

outputTime = p.Results.outputTime;
if isempty(outputTime)
	outputTime = t; % estimate phase at inputTime by default
end


if doPlot
	figure;
	figCnt = 0;
	numFig = 6;
end

if (islogical(p.Results.doPrefilter) && p.Results.doPrefilter) || (strcmp(p.Results.doPrefilter,'auto') && strcmp(p.Results.method,'hilbert')) 
	%% bandpass filter sig for frequencies of interest
	
	if isempty(p.Results.filterNumeratorCoefficients)
		if 0
			% bandpass between 8-14 Hz
			filtOrder      = 200;  % Order
			Fc1  = 8;        % First Cutoff Frequency
			Fc2  = 14;       % Second Cutoff Frequency
			flag = 'scale';  % Sampling Flag
			Beta = 0.5;      % Window Parameter
			% Create the window vector for the design algorithm.
			win = kaiser(filtOrder+1, Beta);

			% Calculate the coefficients using the FIR1 function.
			b  = fir1(filtOrder, [Fc1 Fc2]/(Fs/2), 'bandpass', win, flag);
			Hd = dfilt.dffir(b);
		else
			% lowpass below 40 Hz
			filtOrder = 200;  % Order
			Fpass = 40;   % Passband Frequency
			Fstop = 55;   % Stopband Frequency
			Wpass = 1;    % Passband Weight
			Wstop = 1;    % Stopband Weight
			dens  = 20;   % Density Factor

			% Calculate the coefficients using the FIRPM function.
			b  = firpm(filtOrder, [0 Fpass Fstop Fs/2]/(Fs/2), [1 1 0 0], [Wpass Wstop], ...
					   {dens});
			Hd = dfilt.dffir(b);
		end
	else
		b = p.Results.filterNumeratorCoefficients;
	end
	
	
	if p.Results.doPreFilterExtrapolation
		% add a bit of extra signal at the ends to minimize filter edge effects
		% inspired by http://dsp.stackexchange.com/questions/101/how-do-i-extrapolate-a-1d-signal

		modelOrder = floor(length(sig)/5); %TODO: good model order seems to depend on frequencies of interest
		extrapSig = c_extrapolateSignal(sig,length(b)*2,modelOrder);

		if doPlot
			figCnt=figCnt+1;
			c_subplot(figCnt,numFig);
			plot(extrapSig);
			hold all;
			plot(sig);
			legend('Extrapolated raw','Raw')
		end

		origSigLength = length(sig);
		sig = extrapSig;

	end

	sig = filtfilt(b,1,sig);
	
	if p.Results.doPreFilterExtrapolation
		% cut off extrapolated signal
		sig = sig(1:origSigLength);
	end

	if doPlot
		figCnt=figCnt+1;
		c_subplot(figCnt,numFig);
		plot(t,origSig,t,sig)
		legend('Noisy','Filtered')
	end
end

if doPlot && 0
	%% PSD
	%[Pxx,f] = pmtm(noisySig,3,[],Fs)
	[Pxx,f] = pwelch(sig,floor(length(sig)/2),[],[],Fs);
	figCnt=figCnt+1;
	c_subplot(figCnt,numFig);
	plot(f,10*log10(Pxx))
	xlim([0 50])
	title('PSD');
end


origT = t;


%% pre-estimation extrapolation of signal (to minimize boundary effects)
if (islogical(p.Results.doPreEstimationExtrapolation) && p.Results.doPreEstimationExtrapolation) ||...
		(strcmp(p.Results.doPreEstimationExtrapolation,'auto') && strcmp(p.Results.method,'hilbert')) 
	origSigLength = length(sig);
	numAddedPts = floor(length(sig)/2); 
	modelOrder = floor(length(sig)/10);
	extrapSig = c_extrapolateSignal(sig,numAddedPts,modelOrder);
	dt = median(diff(t));
	t = [t (t(end) + (1:numAddedPts)*dt)];
	if doPlot && 1
		figCnt=figCnt+1;
		c_subplot(figCnt,numFig);
		plot(extrapSig);
		hold all;
		plot(sig);
		legend('Extrapolated raw','Raw')
	end
	sig = extrapSig;
end


%% Estimate phase

persistent warningIssued;
if isempty(warningIssued), warningIssued = false; end;

% choose which method to use for phase estimation
switch p.Results.method
	case 'morlet-symmetric'
		
		if isempty(p.Results.morlet_Fc)
			error('Morlet center frequency (''morlet_Fc'') not specified.');
		end
		
		%% construct wavelet
		numCycles = p.Results.morlet_numCycles;
		Fc = p.Results.morlet_Fc;
		
		% http://dsp.stackexchange.com/a/10206/20621
		N = p.Results.morlet_bandwidthN; % number of standard deviations to span with specified numCycles
		Fb = 2*numCycles^2/(N*2)^2/Fc^2;
		
		x = -1/Fc*numCycles/2:1/Fs:1/Fc*numCycles/2;
		
		[wvt,X] = cmorwavf(min(x),max(x),length(x),Fb,Fc);
		%assert(max(abs(x-X))<10*eps);
		%assert(abs(1/median(diff(X))-Fs)<1e-8);
		
		% calculate phase correction factor to compensate for edge effects
		% if a pure sinusoid of the 'correct' frequency abruptly stops, the phase estimate from 
		%	convolution with the morlet wavelet will be slightly biased within one wavelet length on each side
		if 0 %TODO: delete
			% test case to illustrate issue
			keyboard
			%%
			t = -1:1/Fs:1;
			sig = sin(t*2*pi*Fc+pi/15);
			cleanPhase = angle(hilbert(sig));
			sig(t>0)=0;
			
			figure;
			figCnt=0;
			figCnt=figCnt+1;
			c_subplot(figCnt,numFig);
			plot(t,sig);
			
			convSig = conv2(sig,wvt);
			
			numAddedSamples = length(convSig) - length(sig);
			dt = 1/Fs; %dt = median(diff(t));
			t = [t(1)-floor(numAddedSamples/2)*dt:dt:t(1)-dt, t, max(t)+dt:dt:t(end)+ceil(numAddedSamples/2)*dt];
			sharedIndices = ceil(numAddedSamples/2)+1:length(t)-floor(numAddedSamples/2);
			
			figCnt=figCnt+1;
			c_subplot(figCnt,numFig);
			plot(t,abs(convSig));
			
			figCnt=figCnt+1;
			c_subplot(figCnt,numFig);
			plot(t,angle(convSig));
			
			figCnt=figCnt+1;
			c_subplot(figCnt,numFig);
			plot(t(2:end),12-diff(unwrap(angle(convSig)))/(2*pi*dt));
			ylabel('Error in instantaneous frequency (Hz)')
			xlim([-0.5 0]);
			
			figCnt=figCnt+1;
			c_subplot(figCnt,numFig);
			plot(t(sharedIndices),cleanPhase - angle(convSig(sharedIndices)));
			ylabel('Error in phase')
			xlim([-0.5 0]);
			ylim([-1 1]/8);
		end
			
		
		
		if doPlot
			figCnt=figCnt+1;
			c_subplot(figCnt,numFig);
			plot(x,real(wvt));
			hold all;
			plot(x,imag(wvt));
			legend('Real','Imag')
			title(sprintf('Morlet wavelet %.2g Hz',Fc));			
		end
		
		
		%% apply to signal
		convSig = conv(sig,wvt);
		
		% cut out edge samples as needed
		if p.Results.morlet_fractionOfWaveletToExclude > 0
			numSamplesToExclude = round(p.Results.morlet_fractionOfWaveletToExclude * length(wvt));
			convSig = convSig(numSamplesToExclude+1:end-numSamplesToExclude);
		end
		
		% convolution and trimming probably changed length of signal. Update t to match this
		numAddedSamples = length(convSig) - length(sig);
		if numAddedSamples > 0
			dt = 1/Fs; %dt = median(diff(t));
			% this might be off by one, depending on whether odd sample goes at beginning or end
			t = [t(1)-floor(numAddedSamples/2)*dt:dt:t(1)-dt, t, t(end)+dt:dt:t(end)+ceil(numAddedSamples/2)*dt];
		else
			numRemovedSamples = -numAddedSamples;
			t = t(floor(numRemovedSamples/2)+1:end-ceil(numRemovedSamples/2));
		end
		assert(length(t)==length(convSig));
		
		estimatedEnvelope = abs(convSig);
		inputEnvelope = nan(size(origT));
		%TODO: assign input envelope values where origT and t match
		estimatedPhase = angle(convSig);
		
		phaseLockFrequency = median(diff(unwrap(estimatedPhase))*Fs)/(2*pi);
		
		
	case 'morlet-causal'
		
		if isempty(p.Results.morlet_Fc)
			error('Morlet center frequency (''morlet_Fc'') not specified.');
		end
		
		%% construct wavelet
		numCycles = 6; % actually half this
		
		Fc = p.Results.morlet_Fc;
		Fb = Fc/1000; %TODO: make this another parameter
		
		x = -1/Fc*numCycles/2:1/Fs:0;
		
		[wvt,X] = cmorwavf(min(x),max(x),length(x),Fb,Fc);
		%assert(max(abs(x-X))<10*eps);
		%assert(abs(1/median(diff(X))-Fs)<1e-8);
		
		
		if doPlot
			figCnt=figCnt+1;
			c_subplot(figCnt,numFig);
			plot(x,real(wvt));
			hold all;
			plot(x,imag(wvt));
			legend('Real','Imag')
			title(sprintf('Morlet wavelet %.2g Hz',Fc));
		end
		
		keyboard
		
		% apply to signal
		convSig = conv(sig,wvt);
		
		% cut out edge samples as needed
		if p.Results.morlet_fractionOfWaveletToExclude > 0
			numSamplesToExclude = round(p.Results.morlet_fractionOfWaveletToExclude * length(wvt));
			convSig = convSig(numSamplesToExclude+1:end);
		end
		
		% convolution and trimming probably changed length of signal. Update t to match this
		numAddedSamples = length(convSig) - length(sig);
		if numAddedSamples > 0
			dt = 1/Fs; %dt = median(diff(t));
			% this might be off by one, depending on whether odd sample goes at beginning or end
			t = [t(1)-numAddedSamples*dt:dt:t(1)-dt, t];
		else
			numRemovedSamples = -numAddedSamples;
			t = t(numRemovedSamples+1:end);
		end
		assert(length(t)==length(convSig));
		
		estimatedEnvelope = abs(convSig);
		inputEnvelope = nan(size(origT));
		%TODO: assign input envelope values where origT and t match
		estimatedPhase = angle(convSig);
		
		phaseLockFrequency = median(diff(unwrap(estimatedPhase))*Fs)/(2*pi);

	case 'hilbert'
		
		if ~isempty(p.Results.preHilbertWindowFn)
			win = p.Results.preHilbertWindowFn(length(sig));
			sig = sig.*win;
		end	
		
		hilbSig = hilbert(sig);
		
		if p.Results.hilbertPercentToExclude > 0
% 			c_say('Trimming outer %.2g%% of hilbert data to minimize boundary artifacts',p.Results.hilbertPercentToExclude);
			indicesToKeep = floor(length(hilbSig)*p.Results.hilbertPercentToExclude/100/2):...
				ceil(length(hilbSig)*(1-p.Results.hilbertPercentToExclude/100/2));
			hilbSig = hilbSig(indicesToKeep);
			t = t(indicesToKeep);
% 			c_sayDone();			
		end
		
		estimatedPhase = angle(hilbSig);
		
		estimatedEnvelope = abs(hilbSig);
		inputEnvelope = estimatedEnvelope(1:length(origT));
		
		
		if 1
			% estimate phase frequency from average slope
			phaseLockFrequency = median(diff(unwrap(estimatedPhase))*Fs)/(2*pi);
		else
			% estimate phase frequency from instantaneous phase
			[~, locs] = findpeaks(estimatedPhase,'MINPEAKHEIGHT',pi*0.9);
			estimatedPeakTimes = t(locs);
			phaseLockFrequency = 1/median(diff(estimatedPeakTimes));
		end

		
	case 'fft'
		
		%TODO
		keyboard
		
		windowDuration = 0.4;
		outputTime = 0+0.5/12;
		
		timeIndices = t > outputTime - windowDuration & t <= outputTime; % indices of windowDuration s window before outputTime
		sig = p.Results.inputData(timeIndices);
		
		NFFT = 2^nextpow2(length(sig)*10);
		Sig = fftshift(fft(sig.*hamming(length(sig))',NFFT));
		f = -Fs/2:Fs/NFFT:Fs/2-Fs/NFFT;
		
		figure;
		c_subplot(1,2);
		plot(f,abs(Sig));
		xlim([-20 20]);
		c_subplot(2,2);
		plot(f,angle(Sig))
		xlim([-20 20]);
		
		
	otherwise
		error('Unrecognized phase estimation method: %s',p.Results.method);
end

if doPlot
	figCnt=figCnt+1;
	c_subplot(figCnt,numFig);
	plot(t,estimatedEnvelope);
	title('Estimated envelope');
end


if p.Results.estimationPeriodDelay ~= 0
	% predict phase at time (t) using phase at time (t-T*estimationPeriodDelay)
	outputTime = outputTime - 1/phaseLockFrequency * p.Results.estimationPeriodDelay;
end

%% extrapolate / interpolate to other time points as necessary 
[lia,locb] = ismember(outputTime,t);
if all(lia)
	estimatedPhase = estimatedPhase(locb); % sample outputTime points only
else
	% some output times not in inputTime, need to predict outside of data
	f1 = phaseLockFrequency;
	if max(outputTime) - max(t) > 1/f1*3 || min(t) - min(outputTime) > 1/f1*3
		if ~warningIssued
			warning('Asking for extrapolation of phase more than three periods from input data. Estimate likely to be innacurate');
			warningIssued = true;
		end
	end

	% not the most efficient approach, but relatively straightforward:

	% Fit to unwrapped phase, and then extrapolate to new points, before re-wrapping to (-pi,pi)

	switch p.Results.extrapolationMethod
		case 'polynomialFit'
			genFn = @(x,y) polyfit(x,y,p.Results.polynomialFitOrder);
			evalFn = @polyval; 
		case 'smoothingSpline'
			genFn = @(x,y) fit(x',y','smoothingspline');
			evalFn = @feval; 
		case 'weightedLinearFit'
			% we're more confident about phase estimate where envelope is large, so weight smoothing function accordingly.
			weights = sqrt(estimatedEnvelope/max(estimatedEnvelope)); 
			if p.Results.doWeightExtrapolationByTime
				minTime = min(t);
				maxTime = max(t);
				weights = weights .* (t-minTime)/(maxTime-minTime);
			end
			genFn = @(x,y) fit(x',y','poly1','Weights',weights);
			evalFn = @feval;
		case 'extrapolatedSmoothingSpline'
			% use fnxstr() to improve extrapolation behavior
			genFn = @(x,y) fnxtr(csaps(x,y,1/(1+median(diff(x))^3/1e-7)));
			evalFn = @fnval; 
		case 'extrapolatedWeightedSmoothingSpline'
			% we're more confident about phase estimate where envelope is large, so weight smoothing function accordingly.
			weights = sqrt(estimatedEnvelope/max(estimatedEnvelope)); 
			if p.Results.doWeightExtrapolationByTime
				minTime = min(t);
				maxTime = max(t);
				weights = weights .* (t-minTime)/(maxTime-minTime);
			end
			% use fnxstr() to improve extrapolation behavior
			genFn = @(x,y) fnxtr(csaps(x,y,1/(1+median(diff(x))^3/1e-8),[],weights));
			evalFn = @fnval; 
		otherwise
			error('Unrecognized extrapolation method: %s', p.Results.extrapolationMethod);
	end

	f = genFn(t,unwrap(estimatedPhase));

	if doPlot
		reestimatedPhase = evalFn(f,t);
		R = corrcoef(unwrap(estimatedPhase),reestimatedPhase);
		rsq = R(1,2)^2;
		c_saySingle('r^2 of fit with unwrapped phase: %.4g',rsq);
		R = corrcoef(estimatedPhase,c_wrapToPi(reestimatedPhase));
		rsq = R(1,2)^2;
		c_saySingle('r^2 of fit with wrapped phase:   %.4g',rsq);
		
		tmpT = sort(union(t,outputTime));
		reestimatedPhase = evalFn(f,tmpT);

% 		figCnt=figCnt+1;
% 		c_subplot(figCnt,numFig);
% 		plot(tmpT,reestimatedPhase);
% 		hold all;
% 		plot(t(1:end),unwrap(estimatedPhase));
% 		legend('Phase fit','Estimated phase','location','northwest');
% 		title('Unwrapped phase');
		
		figCnt=figCnt+1;
		c_subplot(figCnt,numFig);
		plot(t(2:end),diff(unwrap(estimatedPhase))./diff(t));
		hold all;
		plot(tmpT(2:end),diff(reestimatedPhase)./diff(tmpT));
		legend('Estimated phase','Phase fit','location','northwest');
		title('Diff of unwrapped phase');

		figCnt=figCnt+1;
		c_subplot(figCnt,numFig);
		plot(t(1:end),estimatedPhase);		
		hold all;
		plot(tmpT,c_wrapToPi(reestimatedPhase));
		legend('Estimated phase','Phase fit','location','northwest');
		title('Wrapped phase');
	end

	% predict phase at new points based on polynomial fit
	estimatedPhase = c_wrapToPi(evalFn(f,outputTime));

% 			% Generate synthetic signal with frequency and phase matching existing fit, and then extend to other time points
% 			
% 			keyboard
% 			
% 			synthTimes = outputTime;
% 			syncIndex = length(t); % for now, just choose last time as phase sync time. It's worth considering changing this in the future, because more intermediate times might have more reliable phase estimates.
% 			syncTime = t(syncIndex);
% 			syncPhase = estimatedPhase(syncIndex);
% 			
% 			synthSig = sin(2*pi*f1*(synthTimes-syncTime) + syncPhase);
% 			
% 			estimatedPhase = angle(hilbert(synthSig));

	%TODO: instead, try doing argburg model extrapolation of raw data (described in http://dsp.stackexchange.com/questions/101/how-do-i-extrapolate-a-1d-signal )
	% (and then using Hilbert transform to calculate phase of extrapolated signal)	
end
		
if doPlot && length(estimatedPhase)>1 && 0
	figCnt=figCnt+1;
	c_subplot(figCnt,numFig);
	plot(outputTime,estimatedPhase)
	title('Instantaneous phase');
end

end



function extrapSig = c_extrapolateSignal(sig,numAddedPts,modelOrder)
	if nargin < 3
		modelOrder = floor(length(sig)-1);
	end
	
	modelCoeff = arburg(sig,modelOrder);
	
	extrapSig = zeros(1, length(sig) + numAddedPts);
	
	extrapSig(1:length(sig)) = sig; % do not extrapolate what we already know
	
	[~,zf] = filter(-[0 modelCoeff(2:end)], 1, sig);
	extrapSig((length(sig)+1):end) = filter([0 0], -modelCoeff, zeros(1, length(extrapSig)-length(sig)), zf);
	
end


%%
function test_c_estimatePhase()
clear all; %close all; 

%% generate synthetic signal
Fs = 5000;
tmin = -1;
tmax = 0.5;
t = tmin:1/Fs:tmax;
N = length(t);
N1 = floor(N/8);
Na = floor(N/3);
Nb = floor(2*N/3);

f_0 = 12 % Hz, fundamental frequency of interest in signal

cleanEnvelope = [1*ones(1,Na), 2*ones(1,Nb-Na), 1.5*ones(1,N-Nb)];
cleanSig = [sin(2*pi*f_0*t(1:N1)), cos(2*pi*f_0*t(N1+1:end))].*cleanEnvelope;
cleanPhase = angle(hilbert(cleanSig));

noiseStd = 1;
noisySig = cleanSig + randn(1,length(cleanSig))*noiseStd;

if 1
	[estimatedPhase, estimatedFrequency] = c_estimatePhase(noisySig,Fs,...
		'method','hilbert',...
		'inputTime',t,...
		'doPlot',true);
else
	% morlet test
	[estimatedPhase, estimatedFrequency] = c_estimatePhase(noisySig,Fs,...
		'method','morlet-symmetric',...
		'morlet_Fc',f_0,...
		'doPrefilter',false,...
		'inputTime',t,...
		'doPlot',true);
end
	
	
estimatedFrequency

c_saySingle('Estimated frequency: %.4g Hz',estimatedFrequency);

numFig = 4;
figCnt = 0;
hf = figure;

figCnt=figCnt+1;
c_subplot(figCnt,numFig);
plot(t,noisySig);
hold all;
plot(t,cleanSig);
legend('Noisy signal','Original signal');

figCnt=figCnt+1;
c_subplot(figCnt,numFig);
estimatedPhase = reshape(estimatedPhase,1,length(estimatedPhase));
plot(t,estimatedPhase-cleanPhase);
hold on;
plot(t,c_wrapToPi(estimatedPhase-cleanPhase));
legend('Phase error','Wrapped phase error');
title('Phase estimate error');

% test phase prediction (outside of data time range)

% dataIndices = t<-0.1;
dataIndices = t<0;
% dataIndices = t<1;

origEstimatedPhase = estimatedPhase;
tNew = -0.2:1/Fs:tmax;
testTime = tNew(floor(length(tNew)/2));
testIndex = t==testTime;
testIndexNew = tNew==testTime;

if 1
	[estimatedPhase, estimatedFrequency] = c_estimatePhase(noisySig(dataIndices),Fs,...
		'inputTime',t(dataIndices),...
		'outputTime',t,...
		'doPlot',true,...
		'method','hilbert');
else
	[estimatedPhase, estimatedFrequency] = c_estimatePhase(noisySig(dataIndices),Fs,...
		'inputTime',t(dataIndices),...
		'outputTime',t,...
		'doPlot',true,...
		'method','morlet-symmetric',...
		'morlet_Fc',f_0,...
		'doPrefilter',false);
end
	

figure(hf);
figCnt=figCnt+1;
c_subplot(figCnt,numFig);
plot(t,cleanPhase)
hold all;
%plot(t(dataIndices),origEstimatedPhase(dataIndices));
plot(t,estimatedPhase);
%legend('Actual (from full clean)','Estimated (from full noisy)','Output (extrapolated from partial noisy)');
legend('Actual phase','Estimated phase');
title('Extrapolation test')

c_saySingle('Estimated frequency: %.4g',estimatedFrequency);
c_saySingle('Predicted phase at t==%.3g s: %.3g',tNew(testIndexNew),estimatedPhase(testIndexNew));
c_saySingle('Actual phase at t==%.3g s: %.3g',t(testIndex),cleanPhase(testIndex));

figCnt=figCnt+1;
c_subplot(figCnt,numFig);
plot(t,estimatedPhase-cleanPhase);
hold on;



plot(t,c_wrapToPi(estimatedPhase-cleanPhase));
legend('Phase estimate error','Wrapped phase estimate error');


keyboard

%% test with a range of phases at time 0

M = 200;
phases = linspace(0,2*pi,M);

cleanPhases = nan(length(phases),length(t));
estimatedPhases = nan(size(cleanPhases));
for i=1:length(phases) %TODO: change back to parfor
	%cleanEnvelope = ones(size(t));
	cleanEnvelope = cumsum(randn(1,N));
	cleanEnvelope = cleanEnvelope + min(cleanEnvelope)*2;
	cleanSig = cos(2*pi*f_0*t+phases(i)).*cleanEnvelope;
	cleanPhase = angle(hilbert(cleanSig));
	cleanPhases(i,:) = cleanPhase;

	noiseStd = 1;
	noisySig = cleanSig + randn(1,length(cleanSig))*noiseStd;

	timeIndices = t<0;
	
	if 1
		[estimatedPhase, ~] = c_estimatePhase(noisySig(timeIndices),Fs,...
			'inputTime',t(timeIndices),...
			'outputTime',t,...
			'doPlot',false,...
			'method','hilbert'...
			);
	else
		[estimatedPhase, ~] = c_estimatePhase(noisySig(timeIndices),Fs,...
			'inputTime',t(timeIndices),...
			'outputTime',t,...
			'doPlot',false,...
			'method','morlet-symmetric',...
			'morlet_Fc',f_0...
			);
	end
	
	estimatedPhases(i,:) = estimatedPhase;
end

testPhases = estimatedPhases;
fullPhases = cleanPhases;
fullTimes = t;

estimateError = c_wrapToPi(testPhases - fullPhases);
					
figure;
plot(fullTimes,mean(abs(estimateError),1))
hold all;
plot(fullTimes,mean(estimateError,1));
plot(fullTimes,std(estimateError,1));
plot(fullTimes,prctile(estimateError,75,1),fullTimes,prctile(estimateError,25,1));
plot(fullTimes,prctile(estimateError,[5 95],1));
legend('Mean(abs())','Mean()','Std()','top quartile','bottom quartile','location','northwest')
xlabel('Time (s)');
ylabel('Phase prediction error');
ylim([-pi pi]/2);

[~,testTimeIndex] = min(abs(fullTimes - 0));
testTime = fullTimes(testTimeIndex);

figure('name',sprintf('Histogram of phase estimate errors at t=%.2g',testTime));
title(sprintf('Histogram of phase estimate errors at t=%.2g',testTime));
hist(estimateError(:,testTimeIndex),21);
xlabel('Phase estimate error');
ylabel('Count');
xlim([-pi pi]);

figure('name','Phase estimate error as a function of actual phase');
scatter(fullPhases(:,testTimeIndex),estimateError(:,testTimeIndex));
xlabel('Actual phase');
ylabel('Phase error');
ylim([-pi pi]/2);







keyboard




end
